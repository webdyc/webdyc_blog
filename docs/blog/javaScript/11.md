---
title: '面向对象深入理解'
categories:
 - 前端笔记
tags:
 - javaScript
---
:::warning
其实和面向对象关系并没有那么大，但是他很多理解都是基于面向对象的思想
:::

## JS中THIS的五种情况
`THIS`：全局上下文中的THIS是WINDOW;块级上下文中没有自己的THIS,它的THIS是继承所在上下文中的THIS的；在函2数的私有上下文中，THIS的情况会多种多样，也是接下来我们重点研究的  
`THIS`不是执行上下文（EC才是执行上下文），THIS是执行主体

1. 事件绑定:  
给元素的某个事件行为绑定方法，当事件行为出发，方法执行，方法中的THIS是当前元素本身（特殊：IE6~8中基于attachEvent方法实现的DOM2事件绑定，事件触发，方法中的THIS是WINDOW而不是元素本身）
```js
// DOM0
let body = document.body
body.onclick = function(){
    // 事件触发，方法执行，方法中的THIS是BODY
    console.log(this)
}
// DOM2
body.addEventListener('click',function(){
    console.log(this) //=> BODY
})
// IE6~8中的DOM2事件绑定
box.attachEvent('onclick',function(){
    console.log(this) //=> window
})
```
2. 普通函数执行(包含自执行、普通函数执行、对象成员访问调取方法执行等)  
只需要看函数执行的时候，方法名前面是否有点，有点，点前面是谁THIS就是谁，没有点THIS就是WINDOW[非严格模式]/UNDEFINDE[严格模式],和在哪执行以及在哪定义，没有关系
```js

// "us strict"
(function(){
    console.log(this) //=> window
})()

let obj = {
    fn:(function(){
        console.log(this) //=> windwo
        return function(){}
    })() //把自执行函数执行的返回值赋值给OBJ.FN
}

function func(){
    console.log(this)
}
let obj = {
    func: func
}
func() //=> window
obj.func() //=> obj

[].slice() //=> 数组实例基于原型链机制，找到ARRAY原型上的SLICE方法（[].slice），然后再把SLICE方法执行，此时SLICE方法中的THIS是当前的空数组
Array.prototype.slice() //=>SLICE方法执行中的THIS: Array.prototype
[].__ptoto__.slice() //=>SLICE方法执行中的THIS:[].__proto__ === Array.prototype

function func(){
    console.log(this) //=> window
}
document.body.onclick = function(){
    // THIS => BODY
    func()
}
```
3. 构造函数执行
构造函数体中的THIS是当前类的实例
```js
function Func(){
    this.name = 'F'
    console.log(this) //=> 构造函数体中的THIS在“构造函数执行”的模式下，是当前类的一个实例，并且THIS.XXX=XXX是给当前实例设置的私有属性
}
Func.prototype.getNum = function getNum(){
    console.log(this) //=> 原型上的方法中的THIS不一定都是实例，主要看执行的时候，点前面的内容 
}
let f = new Func
f.getNum()
f.__proto__.getNum()
f.prototype.getNum()
```
- ES6中提供了ARROW FUNCTION (箭头函数)
箭头函数没有自己的THIS，它的THIS是继承所在上下文中的THIS
```js
let obj = {
    func: function (){
        console.log(this)
    },
    sum: ()=>{
        console.log(this)
    }
}
obj.func() //=> obj
obj.sum() //=> 所在上下文EC(G)THIS => window
obj.sum.call(obj) //=> 箭头函数是没有THIS, 所以强制改也没用 => window

let obj = {
    i:0,
    func(){
        // THIS:OBJ
        setTimeout(function(){
            //THIS: WINDOW 回调函数中的THIS一般都是WINDOW（但是有特殊情况）
            this.i++
            console.log(obj)
        },1000)
    }
}
obj.func()
```
:::tip
不建议乱用箭头函数（部分需求用箭头函数还是很方便的）
:::
4. call/apply/bind
强制手动改变函数中的THIS指向，这三种模式是很直接很暴力的，（前三种情况在使用这三个方法后，都以手动改变的为主）
```js

```
### 练习
```js
var num = 10
var obj = {
    num: 20
} 
obj.fn = (function(num){
    this.num = num * 3
    num++
    return function(n){
        this.num += n
        num++
        console.log(num)
    }
})(obj,num)
var fn = obj.fn
fn(5) //=> 22
obj.fn(10) //=> 23
console.log(num,onj.num) //=> 65 30
```
<img src="https://webdyc.oss-cn-beijing.aliyuncs.com/blog/20210430.png" alt="dyc" title="dyc" class="zoom-custom-imgs">

