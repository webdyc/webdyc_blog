---
title: '常见的数据结构和算法'
date: 2018-10-05
categories:
- javaScript
tags:
- 笔记
- 数据结构
- 算法
---

## 几种使用基础的数据结构详解
数据结构是计算机存储、组织数据的方式；算法是解决问题的方法/步骤和策略
- 有穷性
必须能在执行有限个步骤之后终止
- 确切性
每一步有确切的定义
- 输入项
有0个或者多个输入，以刻画运算对象的初始情况
- 输出项
由一个或者多个输出，以反映对输入数据加工后的结果
- 可行性
每个计算步骤都可以在有限时间内完成

## 数组结构
js中的数组结构非常的简单（已经是浏览器封装处理好了的）
- 可以存储不同的数据类型
- 数组容量伴随存储的内容自动缩放
- Array.prototype上提供很多供数组操作的方法
:::tip
优势：基于索引直接进行查找和获取，效率很高
劣势：进行中间插入和删除操作时，性能非常低（数组塌陷和删除中间项的优化）  
:::
1. 删除数组
```js
let arr = [10, 20, 30, 40, 50]
arr.splice(1,0,100)
arr.shift()
// 后面每一项的索引都会改变，如果项很多的话（消耗性能）
```
2. 数组塌陷
- 删除指定某一项优化
```js
let arr = [10, 20, 30, 40, 50]
// arr.splice(1, 1)
// console.log(arr)
// 优化方式：在不考虑顺序的情况下，我们让最后一项替换当前项,再删除最后一项
// arr[1] = arr[arr.length - 1]
// arr.length--

for(let i=0; i<arr.length; i++){
    if(i===1){
        arr.splice(i,1) // [10,30,40,50]
    }
}

```

## 栈结构Stack
- 后进先出 LIFO
- 只能在一段操作（顶端front）：包括增加（进栈）和删除（出栈）
- 递归算法中的无限递归会出现栈溢出
例： 
1. 颠倒顺序，此处要求原始栈的顺序颠倒，而不是输出一个新栈  
方法有使用一或二个辅助栈、递归等，具体看链接，讲的很好，侵删-.-
2. 最小栈问题，添加一个min函数，能够得到栈的最小元素。要求函数min、push以及pop的时间复杂度都是O(1)。  
使用一个辅助栈来同步记录当前栈中最小元素的位置，每当元素进栈或者出栈时，更新辅助栈（即进栈一个记录位置的元素或出栈一个元素）。
3. push、pop序列，给出两个序列（设每个序列内的元素各不相同），其中一个序列表示栈的push序列，判断另一个序列有没有可能是push序列对应的pop序列。  
将push序列元素依次压进栈；同时比较栈顶元素是否与pop序列的第一个元素相同，是则出栈，再判断pop序列的下一个元素；若不相同或栈已空，则继续将下一个push序列元素进栈；重复以上操作，直到push序列都已进栈完毕。然后判断此时的栈是否为空即可。
4. 用栈实现队列  
使用两个栈（设为 stackA 和 stackB ）来实现队列，stackA负责入栈操作，stackB负责出栈。
入栈：若stackA未满，则入栈 stackA.push;
若stackA已满，则判断stackB是否是空的，如果是空的，则将stackA的元素出栈并入栈到stackB，再将元素入栈stackA；如果stackB非空，则报错提示 “栈（队列？）已满” ，或使用更多的栈来负责出栈。。。
出栈：若stackB为空，则将stackA中的元素全部压入stackB，然后在出栈stackB栈顶元素。
若stackB非空，则直接出栈。
## 队列
- 先进先出（FIFO）
例：
- 滑动窗口最大值（最小值同理可得），转自LeetCode
+ 暴力破解：最简单直接的方法是遍历每个滑动窗口，找到每个窗口的最大值，使用一个数组记录每个窗口出现的最大值。一共有 N - k + 1 个滑动窗口，每个有 k 个元素，故需要N-k+1大小的数组来辅助记录，于是算法的时间复杂度为 O(Nk)，空间复杂度为O(N-k+1)表现较差。
+ 双端队列（deque）：
1. 处理前 k 个元素，初始化双端队列。 遍历整个数组。
2. 在每一步 ：清理双端队列 : 只保留当前滑动窗口中包含的元素的索引； 移除比当前元素小的所有元素，它们不可能是最大的。
3. 将当前元素添加到双向队列中。
4. 将 deque[0] 添加到输出中。
5. 返回输出数组。
6. 时间复杂度：O(N)，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。
7. 空间复杂度：O(N)，输出数组使用了 O(N−k+1)空间，双向队列使用了 O(k)。
+ 动态规划
1. 将测试数组 nums 划分为多个包含k个元素的块，若数组长度n%k!=0，则最后一个块包含的元素少于k。
2. 建立两个数组left和right，长度为n。
3. 使用for循环遍历整个测试数组（窗口滑动）：
4. left[ i ]（此时窗口从左往右滑动）记录窗口滑动到测试数组第 i 个位置时窗口中的最大值，但当 i % k == 0；时，证明窗口滑动到了新的块中，此时left[ i ] 记录值应为测试数组第 i 个值。right数组则是记录窗口从右往左滑动的最大值
```js
if (i % k == 0) 
	left[i] = nums[i];
else 
	left[i] = Math.max(left[i - 1], nums[i]);
```
解析：窗口滑动时，会出现两种情况：一是窗口在块中滑动，这时left或者right数组记录的都是窗口中的最大值；二是窗口跨越了两个块，此时left记录窗口中右边那个块中的最大值，而right则记录左边那个块中的最大值。所以，结果数组就取left和right中的最大值就行。
- 用队列实现栈
+ 使用一个队列来实现
1. 入栈：直接入队即可；
2. 出栈：假设此时队列中现有元素个数为n，则依次将队列中的n-1个元素出队再入队，完成后，队尾元素就变成了队头元素，然后出队即可。
- 使用两个队列来实现
1. 入栈：判断两个队列是否为空，把元素放进非空的队列中（空队列用来进行出栈操作）；若全为空队列，则随便放进一个队列中；
2. 出栈：将非空队列中的 n-1 个元素依次出队，并入队到另一个队列（空的）中，然后将第 n 个元素出队即可。
## 堆结构

## 链表
链表是存储单元上不连续的的存储结构，数据元素的逻辑顺序是通过链表的指针地址来实现的。每个元素包含两个节点。一个节点是存储元素的数据域，另一个节点是指向下一个节点的指针域。根据指针的指向，可以行成不同的结构，例如：单链表，双向链表和循环链表。
- 链表是由一系列的节点组成，这些节点不必在内存中连续，当添加和删除元素的时候，只需要改变相关节点的指针指向即可，效率很高。
- 单链表：最后一个结点的指针域设置为空(NULL)，作为链表的结束标志，表示它没有后继结点。
- 双向链表：每个节点的指针域都有两个指针，分别指向它的后继和前驱，所以，从从任意节点开始，都能方便的访问它的前驱节点和后继节点。
- 循环链表：从单链表可知，最后一个节点的指针域指向NULL，当我们将尾指针指向头结点，那么就形成了一个循环链表。  
优点：
1. 不需要初始化容量，可以任意增减元素。
2. 添加或者删除元素时，只需要改变前后两个元素的指针指向即可，删除和添加元素会很快。  
缺点：
1. 查找元素需要遍历链表来实现，很耗时。
2. 链表存在大量的指针域，占用空间大。
## 树结构
上面的链表、队列、栈，都是线性表，因为其中每个数据元素只有一个前驱和一个后继，是一对一的关系。假如是一对多的关系呢？这种数据结构就是树。树是由n个（n>=0，n=0是，是一棵空树）有限节点构成的，是一个具有层次关系的集合。它看起来像是一棵倒挂的树，也就是说根朝上，而叶子朝下的。
特点：
1. 每个节点具有零个或者多个子节点。
2. 没有父节点的节点称为根节点。
3. 每一个非根节点有且只有一个父节点。
4. 除了根节点以外，每个子节点可分为多个不相交的子树。
二叉树是树的一种，每个节点最多可具有两个子树，即结点的度最大为2（结点度：结点拥有的子树数）。
## 哈希


[参考文档](https://blog.csdn.net/weixin_48726650/article/details/107789164)

